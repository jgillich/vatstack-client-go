/*
Vatstack API Specification

A suite of VAT APIs which let you validate VAT numbers with government services, look up VAT rates by ISO country code, calculate price quotes with centralized VAT rules and store transactions with each sale for VAT reporting.

API version: 1.3.0
Contact: team@vatstack.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vatstack

import (
	"encoding/json"
	"time"
)

// checks if the Batch type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Batch{}

// Batch Batch mass VAT number validations for due dates. Add VAT numbers in bulk or append VAT numbers incrementally to your existing batch process, then start it whenever required.
type Batch struct {
	// ISO date at which the object was created.
	Created *time.Time `json:"created,omitempty"`
	// Unique identifier for the object.
	Id *string `json:"id,omitempty"`
	// Descriptive name of the object.
	Name string `json:"name"`
	// Array of all queries in the order of your input.
	Queries []string `json:"queries,omitempty"`
	// Array of all queries which are of invalid format. Ignored queries are automatically identified upon your input. Its items will not be validated.
	QueriesIgnored []string `json:"queries_ignored,omitempty"`
	// ISO date at which the object status was changed to `scheduled`. Defaults to `null` while the status is `pending`.
	Scheduled *time.Time `json:"scheduled,omitempty"`
	// The number of `validations` where `valid` is `true` or `false`. Itâ€™s an indicator for how far the batch has progressed.
	SucceededCount *int32 `json:"succeeded_count,omitempty"`
	// ISO date at which the object was updated.
	Updated *time.Time `json:"updated,omitempty"`
	// Array of the first 20 validation objects in the order of `queries`. If an `id` is shown in the object, it was created for the batch and you can retrieve it individually. See [validation object](https://vatstack.com/docs/validations) for reference.
	Validations []Validation `json:"validations,omitempty"`
}

// NewBatch instantiates a new Batch object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewBatch(name string) *Batch {
	this := Batch{}
	this.Name = name
	return &this
}

// NewBatchWithDefaults instantiates a new Batch object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewBatchWithDefaults() *Batch {
	this := Batch{}
	return &this
}

// GetCreated returns the Created field value if set, zero value otherwise.
func (o *Batch) GetCreated() time.Time {
	if o == nil || IsNil(o.Created) {
		var ret time.Time
		return ret
	}
	return *o.Created
}

// GetCreatedOk returns a tuple with the Created field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetCreatedOk() (*time.Time, bool) {
	if o == nil || IsNil(o.Created) {
		return nil, false
	}
	return o.Created, true
}

// HasCreated returns a boolean if a field has been set.
func (o *Batch) HasCreated() bool {
	if o != nil && !IsNil(o.Created) {
		return true
	}

	return false
}

// SetCreated gets a reference to the given time.Time and assigns it to the Created field.
func (o *Batch) SetCreated(v time.Time) {
	o.Created = &v
}

// GetId returns the Id field value if set, zero value otherwise.
func (o *Batch) GetId() string {
	if o == nil || IsNil(o.Id) {
		var ret string
		return ret
	}
	return *o.Id
}

// GetIdOk returns a tuple with the Id field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetIdOk() (*string, bool) {
	if o == nil || IsNil(o.Id) {
		return nil, false
	}
	return o.Id, true
}

// HasId returns a boolean if a field has been set.
func (o *Batch) HasId() bool {
	if o != nil && !IsNil(o.Id) {
		return true
	}

	return false
}

// SetId gets a reference to the given string and assigns it to the Id field.
func (o *Batch) SetId(v string) {
	o.Id = &v
}

// GetName returns the Name field value
func (o *Batch) GetName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Name
}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
func (o *Batch) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Name, true
}

// SetName sets field value
func (o *Batch) SetName(v string) {
	o.Name = v
}

// GetQueries returns the Queries field value if set, zero value otherwise.
func (o *Batch) GetQueries() []string {
	if o == nil || IsNil(o.Queries) {
		var ret []string
		return ret
	}
	return o.Queries
}

// GetQueriesOk returns a tuple with the Queries field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetQueriesOk() ([]string, bool) {
	if o == nil || IsNil(o.Queries) {
		return nil, false
	}
	return o.Queries, true
}

// HasQueries returns a boolean if a field has been set.
func (o *Batch) HasQueries() bool {
	if o != nil && !IsNil(o.Queries) {
		return true
	}

	return false
}

// SetQueries gets a reference to the given []string and assigns it to the Queries field.
func (o *Batch) SetQueries(v []string) {
	o.Queries = v
}

// GetQueriesIgnored returns the QueriesIgnored field value if set, zero value otherwise.
func (o *Batch) GetQueriesIgnored() []string {
	if o == nil || IsNil(o.QueriesIgnored) {
		var ret []string
		return ret
	}
	return o.QueriesIgnored
}

// GetQueriesIgnoredOk returns a tuple with the QueriesIgnored field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetQueriesIgnoredOk() ([]string, bool) {
	if o == nil || IsNil(o.QueriesIgnored) {
		return nil, false
	}
	return o.QueriesIgnored, true
}

// HasQueriesIgnored returns a boolean if a field has been set.
func (o *Batch) HasQueriesIgnored() bool {
	if o != nil && !IsNil(o.QueriesIgnored) {
		return true
	}

	return false
}

// SetQueriesIgnored gets a reference to the given []string and assigns it to the QueriesIgnored field.
func (o *Batch) SetQueriesIgnored(v []string) {
	o.QueriesIgnored = v
}

// GetScheduled returns the Scheduled field value if set, zero value otherwise.
func (o *Batch) GetScheduled() time.Time {
	if o == nil || IsNil(o.Scheduled) {
		var ret time.Time
		return ret
	}
	return *o.Scheduled
}

// GetScheduledOk returns a tuple with the Scheduled field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetScheduledOk() (*time.Time, bool) {
	if o == nil || IsNil(o.Scheduled) {
		return nil, false
	}
	return o.Scheduled, true
}

// HasScheduled returns a boolean if a field has been set.
func (o *Batch) HasScheduled() bool {
	if o != nil && !IsNil(o.Scheduled) {
		return true
	}

	return false
}

// SetScheduled gets a reference to the given time.Time and assigns it to the Scheduled field.
func (o *Batch) SetScheduled(v time.Time) {
	o.Scheduled = &v
}

// GetSucceededCount returns the SucceededCount field value if set, zero value otherwise.
func (o *Batch) GetSucceededCount() int32 {
	if o == nil || IsNil(o.SucceededCount) {
		var ret int32
		return ret
	}
	return *o.SucceededCount
}

// GetSucceededCountOk returns a tuple with the SucceededCount field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetSucceededCountOk() (*int32, bool) {
	if o == nil || IsNil(o.SucceededCount) {
		return nil, false
	}
	return o.SucceededCount, true
}

// HasSucceededCount returns a boolean if a field has been set.
func (o *Batch) HasSucceededCount() bool {
	if o != nil && !IsNil(o.SucceededCount) {
		return true
	}

	return false
}

// SetSucceededCount gets a reference to the given int32 and assigns it to the SucceededCount field.
func (o *Batch) SetSucceededCount(v int32) {
	o.SucceededCount = &v
}

// GetUpdated returns the Updated field value if set, zero value otherwise.
func (o *Batch) GetUpdated() time.Time {
	if o == nil || IsNil(o.Updated) {
		var ret time.Time
		return ret
	}
	return *o.Updated
}

// GetUpdatedOk returns a tuple with the Updated field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetUpdatedOk() (*time.Time, bool) {
	if o == nil || IsNil(o.Updated) {
		return nil, false
	}
	return o.Updated, true
}

// HasUpdated returns a boolean if a field has been set.
func (o *Batch) HasUpdated() bool {
	if o != nil && !IsNil(o.Updated) {
		return true
	}

	return false
}

// SetUpdated gets a reference to the given time.Time and assigns it to the Updated field.
func (o *Batch) SetUpdated(v time.Time) {
	o.Updated = &v
}

// GetValidations returns the Validations field value if set, zero value otherwise.
func (o *Batch) GetValidations() []Validation {
	if o == nil || IsNil(o.Validations) {
		var ret []Validation
		return ret
	}
	return o.Validations
}

// GetValidationsOk returns a tuple with the Validations field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Batch) GetValidationsOk() ([]Validation, bool) {
	if o == nil || IsNil(o.Validations) {
		return nil, false
	}
	return o.Validations, true
}

// HasValidations returns a boolean if a field has been set.
func (o *Batch) HasValidations() bool {
	if o != nil && !IsNil(o.Validations) {
		return true
	}

	return false
}

// SetValidations gets a reference to the given []Validation and assigns it to the Validations field.
func (o *Batch) SetValidations(v []Validation) {
	o.Validations = v
}

func (o Batch) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Batch) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Created) {
		toSerialize["created"] = o.Created
	}
	if !IsNil(o.Id) {
		toSerialize["id"] = o.Id
	}
	toSerialize["name"] = o.Name
	if !IsNil(o.Queries) {
		toSerialize["queries"] = o.Queries
	}
	if !IsNil(o.QueriesIgnored) {
		toSerialize["queries_ignored"] = o.QueriesIgnored
	}
	if !IsNil(o.Scheduled) {
		toSerialize["scheduled"] = o.Scheduled
	}
	if !IsNil(o.SucceededCount) {
		toSerialize["succeeded_count"] = o.SucceededCount
	}
	if !IsNil(o.Updated) {
		toSerialize["updated"] = o.Updated
	}
	if !IsNil(o.Validations) {
		toSerialize["validations"] = o.Validations
	}
	return toSerialize, nil
}

type NullableBatch struct {
	value *Batch
	isSet bool
}

func (v NullableBatch) Get() *Batch {
	return v.value
}

func (v *NullableBatch) Set(val *Batch) {
	v.value = val
	v.isSet = true
}

func (v NullableBatch) IsSet() bool {
	return v.isSet
}

func (v *NullableBatch) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBatch(val *Batch) *NullableBatch {
	return &NullableBatch{value: val, isSet: true}
}

func (v NullableBatch) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBatch) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


